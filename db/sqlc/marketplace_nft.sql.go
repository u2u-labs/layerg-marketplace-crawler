// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: marketplace_nft.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const upsertNFT = `-- name: UpsertNFT :one
INSERT INTO nft (uid, "tokenId", name, "createdAt", "updatedAt", status, "tokenUri", "txCreationHash",
                 "creatorId", "collectionId", "chainId", image, description, "animationUrl",
                 "nameSlug", "metricPoint", "metricDetail", source)
VALUES (COALESCE($1, gen_random_uuid()), $2, $3, $4, $5, $6, $7, $8,
        $9, $10, $11, $12, $13, $14,
        $15, $16, $17, $18)
ON CONFLICT ("tokenId", "collectionId", "chainId")
    DO UPDATE SET name             = EXCLUDED.name,
                  "updatedAt"      = CURRENT_TIMESTAMP,
                  status           = EXCLUDED.status,
                  "tokenUri"       = EXCLUDED."tokenUri",
                  "txCreationHash" = EXCLUDED."txCreationHash",
                  "creatorId"      = EXCLUDED."creatorId",
                  image            = EXCLUDED.image,
                  description      = EXCLUDED.description,
                  "animationUrl"   = EXCLUDED."animationUrl",
                  "nameSlug"       = EXCLUDED."nameSlug",
                  "metricPoint"    = EXCLUDED."metricPoint",
                  source           = EXCLUDED.source
RETURNING uid, "tokenId", name, "createdAt", "updatedAt", status, "tokenUri", "txCreationHash", "creatorId", "collectionId", "chainId", image, description, "animationUrl", "nameSlug", "metricPoint", "metricDetail", source
`

type UpsertNFTParams struct {
	Column1        interface{}     `json:"column1"`
	TokenId        string          `json:"tokenId"`
	Name           string          `json:"name"`
	CreatedAt      time.Time       `json:"createdAt"`
	UpdatedAt      time.Time       `json:"updatedAt"`
	Status         string          `json:"status"`
	TokenUri       string          `json:"tokenUri"`
	TxCreationHash string          `json:"txCreationHash"`
	CreatorId      sql.NullString  `json:"creatorId"`
	CollectionId   string          `json:"collectionId"`
	ChainId        int64           `json:"chainId"`
	Image          sql.NullString  `json:"image"`
	Description    sql.NullString  `json:"description"`
	AnimationUrl   sql.NullString  `json:"animationUrl"`
	NameSlug       sql.NullString  `json:"nameSlug"`
	MetricPoint    int64           `json:"metricPoint"`
	MetricDetail   json.RawMessage `json:"metricDetail"`
	Source         sql.NullString  `json:"source"`
}

func (q *Queries) UpsertNFT(ctx context.Context, arg UpsertNFTParams) (Nft, error) {
	row := q.db.QueryRowContext(ctx, upsertNFT,
		arg.Column1,
		arg.TokenId,
		arg.Name,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Status,
		arg.TokenUri,
		arg.TxCreationHash,
		arg.CreatorId,
		arg.CollectionId,
		arg.ChainId,
		arg.Image,
		arg.Description,
		arg.AnimationUrl,
		arg.NameSlug,
		arg.MetricPoint,
		arg.MetricDetail,
		arg.Source,
	)
	var i Nft
	err := row.Scan(
		&i.Uid,
		&i.TokenId,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.TokenUri,
		&i.TxCreationHash,
		&i.CreatorId,
		&i.CollectionId,
		&i.ChainId,
		&i.Image,
		&i.Description,
		&i.AnimationUrl,
		&i.NameSlug,
		&i.MetricPoint,
		&i.MetricDetail,
		&i.Source,
	)
	return i, err
}
